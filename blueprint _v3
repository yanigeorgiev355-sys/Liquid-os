This is the correct professional decision. We are moving from "School Project" (Hardcoded Apps) to "Enterprise Architecture" (The Atomic Engine).
This Blueprint v3 is your new "North Star." It replaces all previous blueprints. It defines the strict rules of the game so the AI can be "limitless" without breaking the code.
IMMEDIATE ACTION: Create a new file in your project called BLUEPRINT_v3.md and paste this content in. This file will be the context you provide to every future AI chat session.
ðŸ“˜ Liquid OS: The Master Blueprint (v3.0)
Code Name: The Atomic Engine
Date: February 11, 2026
Status: Architecture Definition
Goal: Infinite Tool Generation via Strict Protocols
1. The Core Philosophy
"We do not build Apps. We build Atoms."
 * Old Way (v1/v2): The AI says "Build a Coin Flipper," and we hardcode a <CoinFlipper /> component. This is slow and limited.
 * New Way (v3): The AI says "I need a random boolean generator." The OS replies by assembling a Button, a Text label, and a Logic block.
   * Result: The user gets a Coin Flipper. But tomorrow, they can ask for a "Dice Roller" or a "Tax Calculator," and the OS builds it instantly using the same atoms.
2. System Architecture (The "Triad")
This is the professional separation of concerns.
A. The Brain (Gemini 2.5 Flash)
 * Role: The Architect.
 * Job: It listens to the user and outputs a JSON Receipt (The Blueprint).
 * Constraint: It cannot write React code. It can only select from the Atomic Menu.
B. The Body (React + Vite)
 * Role: The Builder.
 * Job: It receives the JSON Receipt and renders the pixels.
 * Key Feature: "The Universal Renderer." A single component that loops through the JSON and renders the correct atom for each line.
C. The Soul (Firebase Firestore)
 * Role: The Memory.
 * Job: Stores the "State" of every tool.
 * Innovation: "Liquid State." The data is not locked in an app. If the "Coffee Tracker" saves caffeine: 200, the "Sleep Tracker" can read that data later.
3. The Atomic Protocol (The "Contract")
The AI is strictly forbidden from hallucinating components. It may only use these 6 Atoms. This is the component_library we will build.
| Atom Name | JSON Type | Purpose | Props (Inputs) |
|---|---|---|---|
| Hero | hero | Big displays (Time, Money, Score) | label, value, color |
| Input | input | User enters data (Text, Numbers) | label, type (text/number), id |
| Action | button | Triggers a logic event | label, action_id, color |
| List | list | Scrollable history | source_collection, limit |
| Chart | chart | Visualizing data trends | type (line/bar), data_source |
| Container | box | Layout grouper (Row/Column) | direction, children |
4. The Data Flow (How it Works)
User: "I want to track my daily water intake. Goal is 3 liters."
Step 1: The Brain (Gemini) Analysis
Gemini generates this JSON (The Plan):
{
  "tool_id": "water_tracker_v1",
  "layout": [
    { "type": "hero", "label": "Hydration Level", "value": "{water_current} / 3000ml", "color": "blue" },
    { "type": "box", "direction": "row", "children": [
        { "type": "button", "label": "+250ml (Cup)", "action": "add_water_250" },
        { "type": "button", "label": "+500ml (Bottle)", "action": "add_water_500" }
      ]
    },
    { "type": "list", "source": "water_logs", "label": "History" }
  ],
  "logic": {
    "add_water_250": { "target": "water_current", "operation": "increment", "value": 250 },
    "add_water_500": { "target": "water_current", "operation": "increment", "value": 500 }
  }
}

Step 2: The Body (React) Render
The app sees "type": "hero" and renders <HeroComponent />.
It sees "type": "button" and renders <ButtonComponent />.
Step 3: The Soul (Firebase) Action
When the user clicks +250ml, the Logic Engine reads the JSON:
 * "Target: water_current" -> Go to Firebase.
 * "Operation: increment" -> Add 250.
 * "Update UI" -> The Hero component automatically updates to "250 / 3000ml".
5. Implementation Roadmap (Agile Sprints)
Phase 1: The Foundation (Current Focus)
 * Goal: Build the "Universal Renderer" and the first 3 Atoms (Hero, Button, List).
 * Action: Clean App.tsx. Remove the hardcoded Coin Flipper. Replace it with the Renderer loop.
 * Success Metric: We can manually write a JSON file, and the screen renders a UI without changing React code.
Phase 2: The Brain Connection
 * Goal: Connect Gemini 2.5.
 * Action: Feed the "Atomic Protocol" into the System Prompt.
 * Success Metric: We type "Build a counter," and Gemini sends valid JSON that renders a working counter.
Phase 3: The Memory (Persistence)
 * Goal: "Save/Load" Tools.
 * Action: When a tool is generated, save its JSON definition to Firebase.
 * Success Metric: You refresh the browser, and your "Water Tracker" is still there.
6. Development Rules (The "Professional Way")
 * No Logic in UI: The React components (Button.tsx) must be dumb. They just fire events. The logic lives in the JSON.
 * Context Hygiene: Every time you start a coding session, paste this Blueprint first.
 * JSON Validation: We will install a "Guard" function that checks if Gemini's JSON is valid before trying to render it (prevents White Screen of Death).
Next Steps for the Developer (You)
 * Create BLUEPRINT_v3.md and paste this content.
 * Delete the old App.tsx logic (the coin flipper).
 * Ask Gemini: "Generate the AtomRender.tsx component based on Blueprint v3."
This is the professional standard. We are now building an Engine, not a Toy.
